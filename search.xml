<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[魔鬼在细节中]]></title>
      <url>/knowledge/2017/08/09/%E9%AD%94%E9%AC%BC%E5%9C%A8%E7%BB%86%E8%8A%82%E4%B8%AD/</url>
      <content type="html"><![CDATA[<p>作为一个it小司机，每次在写完代码，自己测了一遍都没发现什么问题，提交给测试的时候反馈回来一大堆的bug，检查发现很多其实都是一些很小的需要注意的细节，但却足以让你的程序瘫痪，平时注意这些小细节，可能会省去好多事。那么在编码中我们应该时候需要注意的规范有哪些呢，这也是在成为一个it老司机的路上必须要经过的一道坎，在这借鉴一下阿里大牛写的一遍魔鬼在细节中。<a id="more"></a></p>
<ul>
<li><ol>
<li>防止空指针和下标越界<br>这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常，<br>这也是一个健状的程序开发人员，在写每一行代码都应在潜意识中防止的异常，<br>基本上要能确保一次写完的代码，在不测试的情况，都不会出现这两个异常才算合格。 </li>
</ol>
</li>
<li><ol>
<li>保证线程安全性和可见性<br>对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求，<br>需要开发人员，在写每一行代码时都应在潜意识中确保其正确性，<br>因为这种代码，在小并发下做功能测试时，会显得很正常，<br>但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。</li>
</ol>
</li>
<li><ol>
<li>尽早失败和前置断言<br>尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言，<br>一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错，<br>因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑，<br>这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。</li>
</ol>
</li>
<li><ol>
<li>分离可靠操作和不可靠操作<br>这里的可靠是狭义的指是否会抛出异常或引起状态不一致，<br>比如，写入一个线程安全的Map，可以认为是可靠的，<br>而写入数据库等，可以认为是不可靠的，<br>开发人员必须在写每一行代码时，都注意它的可靠性与否，<br>在代码中尽量划分开，并对失败做异常处理，<br>并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，<br>保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。</li>
</ol>
</li>
<li><ol>
<li>异常防御，但不忽略异常<br>这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，<br>包括程序上的BUG，比如：获取程序的版本号，会通过扫描Manifest和jar包名称抓取版本号，<br>这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，<br>但应该在整个getVersion()中加上一个全函数的try-catch打印错误日志，并返回基本版本，<br>因为getVersion()可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉try-catch)，<br>而如果它抛出异常会导致主流程异常，这是我们不希望看到的，<br>但这里要控制个度，不要随意try-catch，更不要无声无息的吃掉异常。 </li>
</ol>
</li>
<li><ol>
<li>缩小可变域和尽量final<br>如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类，<br>不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围，<br>就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段final，以免被中途误修改引用，<br>不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值，<br>要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final就是一个不变契约。 </li>
</ol>
</li>
<li><ol>
<li>降低修改时的误解性，不埋雷<br>前面不停的提到代码被其他人修改，这也开发人员要随时紧记的，<br>这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它，<br>我应该给修改的人一点什么提示，让他知道我现在的设计意图，<br>而不要在程序里面加潜规则，或埋一些容易忽视的雷，<br>比如：你用null表示不可用，size等于0表示黑名单，<br>这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，<br>可能后面为了改某个其它BUG，不小心改到了这里，直接引爆故障。<br>对于这个例子，一个原则就是永远不要区分null引用和empty值。 </li>
</ol>
</li>
<li><ol>
<li>提高代码的可测性<br>这里的可测性主要指Mock的容易程度，和测试的隔离性，<br>至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，<br>一般开发人员，加上JUnit等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题，<br>这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)，<br>现在的测试代码，过于强调完备性，大量重复交叉测试，<br>看起来没啥坏处，但测试代码越多，维护代价越高，<br>经常出现的问题是，修改一行代码或加一个判断条件，引起100多个测试用例不通过，<br>时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？<br>久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过，<br>最好的情况是，修改一行代码，有且只有一行测试代码不通过，<br>如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到，<br>另外，可Mock性是隔离的基础，把间接依赖的逻辑屏蔽掉，<br>可Mock性的一个最大的杀手就是静态方法，尽量少用。</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> IT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编码规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[类与类之间的关系]]></title>
      <url>/knowledge/2017/08/01/class-relationship/</url>
      <content type="html"><![CDATA[<p>在面向对象分析的过程中，我们常常会首先分析类与类之间有什么关系，然后设计出合理的类结构，尽量达到低耦合，高内聚。使得程序的可扩展性更高，下面简单的总结一下在面向对象的世界里类与类之间的关系。<a id="more"></a></p>
<ul>
<li><p>1、泛化关系(generalization)<br>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：<br>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)<br>eg：自行车是车、猫是动物<br>泛化关系用一条带空心箭头的直接表示；<br><font color="red">注：</font>最终代码中，泛化关系表现为继承非抽象类；</p>
</li>
<li><p>2、实现关系(realize)<br>实现关系用一条带空心箭头的虚线表示；<br>eg：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才 可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）<br><font color="red">注：</font>最终代码中，实现关系表现为继承抽象类；</p>
</li>
<li><p>3、聚合关系(aggregation)<br>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；<br>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；<br>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p>
</li>
<li><p>4、组合关系(composition)<br>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；<br>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；<br>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p>
</li>
<li><p>5、关联关系(association)<br>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；<br>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；<br>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；<br><font color="red">注：</font>在最终代码中，关联对象通常是以成员变量的形式实现的；</p>
</li>
<li><p>6、依赖关系(dependency)<br>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；<br>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；<br>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；<br><font color="red">注：</font>在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> IT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git 笔记 fork]]></title>
      <url>/knowledge/2017/06/17/git-note1/</url>
      <content type="html"><![CDATA[<p>今天看到一个博客中对git几个命令的总结，感觉讲的通俗易懂，借过来记一笔<br><a id="more"></a></p>
<ul>
<li>需求：B要加入A的项目，不论是作为B的初始项目进行二次开发还是成为A项目的一员加入一起开发，步骤如下：</li>
<li>1.B首先要fork一个。<br>B首先到A的github上，也就是此项目的位置:<a href="https://github.com/A/durit，然后单击fork，然后你（B）的github上就出现了一个fork，位置是：https://github.com/B/durit" target="_blank" rel="external">https://github.com/A/durit，然后单击fork，然后你（B）的github上就出现了一个fork，位置是：https://github.com/B/durit</a></li>
<li>2.B把自己的fork克隆到本地。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/B/durit</div></pre></td></tr></table></figure>
</li>
</ul>
<p>(当你clone到本地，会有一个默认的远程名叫”origin”，它指向了fork on github，也就是B上的fork，而不是指向)</p>
<ul>
<li>3.现在你是主人，为了保持与A的durit的联系，你需要给A的durit起个名，供你来驱使。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> durit</div><div class="line">$ git remote add upstream https://github.com/A/durit</div></pre></td></tr></table></figure>
</li>
</ul>
<p>(现在改名为upstream，这名随意，现在你（B）管A的durit叫upstream，以后B就用upstream来和A的durit联系了)</p>
<ul>
<li>4.获取A上的更新(但不会修改你的文件)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git fetch upstream</div></pre></td></tr></table></figure>
</li>
</ul>
<p>（这不，现在B就用upstream来联系A了）</p>
<ul>
<li>5.合并拉取的数据<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git merge upstream/master</div></pre></td></tr></table></figure>
</li>
</ul>
<p>（又联系了一次，upstream/master，前者是你要合并的数据，后者是你要合并到的数据（在这里就是B本地的durit了））</p>
<ul>
<li>6.在B修改了本地部分内容后，把本地的更改推送到B的远程github上。<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git add 修改过的文件</div><div class="line">$ git commit -m <span class="string">"注释"</span></div><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
</li>
</ul>
<p>（目前为止，B上的github就跟新了）</p>
<ul>
<li><p>7.然后B还想让修改过的内容也推送到A上，这就要发起pull request了。<br>打开B的github,也就是<a href="https://github.com/B/durit" target="_blank" rel="external">https://github.com/B/durit</a><br>点击Pull Requests<br>单击new pull request<br>单击create pull request<br>输入title和你更改的内容<br>然后单击send pull request<br>这样B就完成了工作，然后就等着主人A来操作了。</p>
</li>
<li><p>8.在B想要更新A的github上到内容时，结果冲突，因为B和A同时修改了文件，比如说是README.ME，该这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status(查看冲突文件) //找到冲突文件(README.MD)后，打开并修改，解决冲突后</div><div class="line">$ git add README.MD</div><div class="line">$ git commit -m <span class="string">"解决了冲突文件README.MD"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在冲突解决了，可以更新A的内容了，也就是上面第4步和第5步</p>
]]></content>
      
        <categories>
            
            <category> 上古神器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python 学习笔记1]]></title>
      <url>/knowledge/2017/06/08/python1/</url>
      <content type="html"><![CDATA[<h5 id="Python3中有六个标准的数据类型："><a href="#Python3中有六个标准的数据类型：" class="headerlink" title="Python3中有六个标准的数据类型："></a>Python3中有六个标准的数据类型：</h5><ul>
<li>字符串（String）<br></li>
<li>数字（Digit）</li>
<li>列表（List）<a id="more"></a></li>
<li>元组（Tuple）</li>
<li>集合（Sets）</li>
<li>字典（Dictionary）</li>
<li>日期（date）</li>
<li>布尔 (Boolean)</li>
<li>数值 (Number)</li>
</ul>
<ol>
<li>整型——int——数字<br>python有5种数字类型，最常见的就是整型int。例如：1234、-1234</li>
<li>布尔型——bool——用符号==表示<br>布尔型是一种比较特殊的python数字类型，它只有True和False两种值，它主要用来比较和判断，所得结果叫做布尔值。例如：3==3 给出True，3==5给出False</li>
<li>字符串——str——用’ ‘或” “表示<br>例如：’www.iplaypython.com’或者”hello”</li>
<li>列表——list——用[ ]符号表示<br>例如：[1,2,3,4]</li>
<li>元组——tuple——用( )符号表示<br>例如：（’d’,300）</li>
<li>字典——dict——用{ }符号表示<br>例如：｛’name’:’coco’,’country’:’china’｝</li>
</ol>
<p><a href="http://www.diveintopython3.net/" target="_blank" rel="external">更多内容…</a></p>
]]></content>
      
        <categories>
            
            <category> IT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/knowledge/2017/06/07/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 其他 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hello]]></title>
      <url>/knowledge/2017/04/28/hello/</url>
      <content type="html"><![CDATA[<h5 id="小计一笔"><a href="#小计一笔" class="headerlink" title="小计一笔"></a>小计一笔</h5><p>作为一个做技术的，对所学的技术总结，分享是很重要的，也希望以后多多总结学到的新的东西，分享出来，做一个记录。和更多的人一起去交流，学习。也许，这样才是学习的真正乐趣。<br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> 瞎写 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式的六大原则]]></title>
      <url>/knowledge/2016/04/28/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h4 id="二、设计模式的六大原则"><a href="#二、设计模式的六大原则" class="headerlink" title="二、设计模式的六大原则"></a>二、设计模式的六大原则</h4><ul>
<li><p>1、开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。<a id="more"></a>所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
</li>
<li><p>2、里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
</li>
<li>3、依赖倒转原则（Dependence Inversion Principle）<br>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</li>
<li>4、接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</li>
<li>5、迪米特法则（最少知道原则）（Demeter Principle）<br>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li>6、合成复用原则（Composite Reuse Principle）<br>原则是尽量使用合成/聚合的方式，而不是使用继承。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> IT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>/knowledge/about/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[留言]]></title>
      <url>/knowledge/comment/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[实验室]]></title>
      <url>/knowledge/lab/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/knowledge/photos/index.html</url>
      <content type="html"><![CDATA[<p><link type="text/css" href="/knowledge/css/jquery.fancybox.css" rel="stylesheet"></p>
<p><div class="instagram"><section class="archives album"><ul class="img-box-ul"></ul></section></div></p>
<script src="/knowledge/js/jquery-1.8.2.min.js"></script>
<script src="/knowledge/js/jquery.lazyload.min.js"></script>
<script src="/knowledge/js/jquery.fancybox.js"></script>
<script src="/knowledge/js/photo.js"></script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[友情链接]]></title>
      <url>/knowledge/friends/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/knowledge/photos/output.json</url>
      <content type="html"><![CDATA[["1_b.jpg","1_s.jpg","2_b.jpg","2_s.jpg","3_b.jpg","3_s.jpg","4_b.jpg","4_s.jpg","5_b.jpg","5_s.jpg"]]]></content>
    </entry>
    
  
</search>
